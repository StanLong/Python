# 栈

# 使用栈计算中缀表达式

class ArrayStack:
    stack = [] # 使用数组模拟栈
    top = -1 # 栈顶，默认-1

    def __init__(self, maxSize):
        self.maxSize = maxSize # 定义栈容量
        self.stack = [0 for i in range(maxSize)]

    # 判空
    def isEmpty(self):
        return self.top == -1

    # 判满
    def isFull(self):
        return self.top == self.maxSize -1

    # 入栈
    def push(self, value):
        if self.isFull():
            print("栈满了")
            return
        self.top = self.top + 1
        self.stack[self.top] = value

    # 出栈
    def pop(self):
        if self.isEmpty():
            print("栈空了")
            return
        value = self.stack[self.top]
        self.top = self.top - 1
        return value

    # 查看栈顶元素
    def peek(self):
        return self.stack[self.top]

    # 判断是否是操作符
    def isOper(self, oper):
        return oper == '+' or oper == '-' or oper == '*' or oper == '/'

    # 定义操作符优先级
    def priority(self, oper):
        if oper == '*' or oper == '/':
            return 1
        elif oper == '+' or oper == '-':
            return 0
        else:
            return -1

    # 计算
    def cal(self, num1, num2, oper):
        if oper == '+':
            return num1 + num2
        if oper == '-':
            return num2 - num1
        if oper == '*':
            return num1 * num2
        if oper == '/':
            return num2 / num1

if __name__ == '__main__':
    expression = "3+2*6-2"

    numStack = ArrayStack(10) # 数栈
    operStack = ArrayStack(10) # 符号栈

    # 定义操作要用到的变量
    index = 0 # 帮助遍历表达式
    num1 = 0 # 操作数1
    num2 = 0 # 操作数2
    oper = 0 # 操作符
    result = 0 # 计算结果
    ch = '' # 遍历出的字符
    keyNum = "" # 拼接多位数

    while True:
        ch = expression[index : (index + 1)] # 遍历表达式中的字符
        if operStack.isOper(ch): # 如果是操作符
            if not operStack.isEmpty(): # 如果操作符栈不为空
                # 如果当前操作符的优先级小于等操作符栈顶的优先级， 就从数栈中出栈两个数，操作符栈中出栈一个操作符，进行运算, 并将运算得到结果压入数栈
                if(operStack.priority(ch) <= operStack.priority(operStack.peek())):
                    num1 = numStack.pop()
                    num2 = numStack.pop()
                    oper = operStack.pop()
                    result = operStack.cal(num1, num2, oper)
                    numStack.push(result)
            operStack.push(ch)
        else:
            if not numStack.isOper(expression[index+1:index+2]):
                keyNum = keyNum + ch
            numStack.push(keyNum)

        index = index + 1
        if index == expression.__len__() - 1:
            break

    while True:
        if not operStack.isEmpty():
            num1 = numStack.pop()
            num2 = numStack.pop()
            oper = operStack.pop()
            result = operStack.cal(num1, num2, oper)
            numStack.push(result)
    result = numStack.pop()

    print("%s = %s" %(expression, result))


